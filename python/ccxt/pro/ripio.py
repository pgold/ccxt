# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCache
from ccxt.async_support.base.ws.client import Client
from typing import Optional
from ccxt.base.errors import ArgumentsRequired


class ripio(ccxt.async_support.ripio):

    def describe(self):
        return self.deep_extend(super(ripio, self).describe(), {
            'has': {
                'ws': True,
                'watchOrderBook': True,
                'watchTrades': True,
                'watchTicker': True,
                'watchBalance': True,
                'watchMyTrades': True,
                'watchOrders': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://ws.ripiotrade.co/',
                },
            },
            'options': {
                'tradesLimit': 1000,
                'uuid': self.uuid(),
            },
        })

    async def watch_trades(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the ripio api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' watchTicker() requires a symbol argument')
        await self.load_markets()
        symbol = self.symbol(symbol)
        market = self.market(symbol)
        marketId = self.market_id(symbol)
        name = 'trade@' + marketId
        messageHash = market['id'].lower()
        url = self.urls['api']['ws']
        subscription = {
            'topics': [name],
            'method': 'subscribe',
            'symbol': symbol,
            'messageHash': messageHash,
            'methodToCall': self.handle_trade,
        }
        trades = await self.watch(url, messageHash, subscription, messageHash, subscription)
        #
        #     {
        #         "topic": "trade@ETH_BRL",
        #         "timestamp": 1672856503549,
        #         "body": {
        #             "amount": 0.2404764,
        #             "date": "2019-01-03T02:27:33.947Z",
        #             "id": "2B222F22-5235-45FA-97FC-E9DBFA2575EE",
        #             "maker_order_id": "F49F5BD8-3F5B-4364-BCEE-F36F62DB966A",
        #             "maker_side": "buy",
        #             "maker_type": "limit",
        #             "pair": "ETH_BRL",
        #             "price": 15160,
        #             "taker_order_id": "FEAB5CEC-7F9E-4F95-B67D-9E8D5C739BE3",
        #             "taker_side": "sell",
        #             "taker_type": "market",
        #             "timestamp": 1675780847920,
        #             "total_value": 3638.4
        #         }
        #     }
        #
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp')

    async def watch_ticker(self, symbol: Optional[str] = None, params={}):
        """
        watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: not used by ripio watchTicker
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' watchTicker() requires a symbol argument')
        await self.load_markets()
        symbol = self.symbol(symbol)
        market = self.market(symbol)
        marketId = self.market_id(symbol)
        name = 'ticker@' + marketId
        messageHash = market['id'].lower()
        url = self.urls['api']['ws']
        subscription = {
            'topics': [name],
            'method': 'subscribe',
            'symbol': symbol,
            'messageHash': messageHash,
            'methodToCall': self.handle_ticker,
        }
        ticker = await self.watch(url, messageHash, subscription, messageHash, subscription)
        #
        #     {
        #         "topic": "ticker@ETH_BRL",
        #         "timestamp": 1672856683447,
        #         "body": {
        #             "ask": 4.01,
        #             "base_code": "ETH",
        #             "base_id": "13A4B83B-E74F-425C-BC0A-03A9C0F29FAD",
        #             "bid": 5,
        #             "date": "2022-09-28T19:13:40.887Z",
        #             "high": 20,
        #             "last": 20,
        #             "low": 20,
        #             "pair": "ETH_BRL",
        #             "price_change_percent_24h": "-16.66",
        #             "quote_id": "48898138-8623-4555-9468-B1A1505A9352",
        #             "quote_code": "BRL",
        #             "quote_volume": 600,
        #             "trades_quantity": 10,
        #             "volume": 124
        #         }
        #     }
        #
        return ticker

    async def watch_order_book(self, symbol: Optional[str] = None, limit: Optional[int] = None, params={}):
        """
        watches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: not used by ripio watchOrderBook
        :param dict params: extra parameters specific to the ripio api endpoint
        :param str|None params['level']: orderbook level to be used, level_2 or level_3(if a valid level is not sent, the level_2 will be used by default)
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' watchOrderBook() requires a symbol argument')
        await self.load_markets()
        symbol = self.symbol(symbol)
        market = self.market(symbol)
        marketId = self.market_id(symbol)
        level = self.safe_string(params, 'level')
        if level != 'level_2' and level != 'level_3':
            level = 'level_2'
        name = 'orderbook/' + level + '@' + marketId
        messageHash = market['id'].lower()
        url = self.urls['api']['ws']
        subscription = {
            'topics': [name],
            'method': 'subscribe',
            'symbol': symbol,
            'messageHash': messageHash,
            'methodToCall': self.handle_order_book,
        }
        orderbook = await self.watch(url, messageHash, subscription, messageHash, subscription)
        #
        #     {
        #         "topic": "orderbook/level_2@ETH_BRL",
        #         "timestamp": 1672856653428,
        #         "body": {
        #             "asks": [
        #                 {
        #                     "amount": 10,
        #                     "price": 25
        #                 }
        #             ],
        #             "bids": [
        #                 {
        #                     "amount": 20,
        #                     "price": 4
        #                 }
        #             ],
        #             "pair": "ETH_BRL"
        #         }
        #     }
        #
        return orderbook

    async def watch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: not used by ripio watchBalance
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        await self.load_markets()
        name = 'balance'
        messageHash = name
        url = self.urls['api']['ws']
        ticket = await self.fetchWebSocketTicket()
        subscription = {
            'topics': [name],
            'method': 'subscribe',
            'ticket': ticket,
            'messageHash': messageHash,
            'methodToCall': self.handle_balance,
        }
        balance = await self.watch(url, messageHash, subscription, messageHash, subscription)
        #
        #     {
        #         "topic": "balance",
        #         "timestamp": 1672856833684,
        #         "body": {
        #             "user_id": "299E7131-CE8C-422F-A1CF-497BFA116F89",
        #             "balances": [
        #                 {
        #                     "available_amount": 3,
        #                     "currency_code": "ETH",
        #                     "locked_amount": 1
        #                 }
        #             ]
        #         }
        #     }
        #
        return balance

    async def watch_my_trades(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        watches information on multiple trades made by the user
        :param str symbol: not used by ripio watchMyTrades
        :param int|None since: not used by ripio watchMyTrades
        :param int|None limit: not used by ripio watchMyTrades
        :param dict params: not used by ripio watchMyTrades
        :returns [dict]: a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure
        """
        await self.load_markets()
        name = 'user_trades'
        messageHash = name
        url = self.urls['api']['ws']
        ticket = await self.fetchWebSocketTicket()
        subscription = {
            'topics': [name],
            'method': 'subscribe',
            'ticket': ticket,
            'messageHash': messageHash,
            'methodToCall': self.handle_trade,
        }
        trades = await self.watch(url, messageHash, subscription, messageHash, subscription)
        #
        #     {
        #         "topic": "user_trades",
        #         "timestamp": 1673271591764,
        #         "body": {
        #             "trade": {
        #                 "amount": 1,
        #                 "date": "2023-01-09T13:39:24.057Z",
        #                 "fee": 0,
        #                 "fee_currency": "BCH",
        #                 "id": "08799ECC-F6B1-498E-B89C-2A05E6A181B9",
        #                 "pair_code": "BCH_BRL",
        #                 "price": 49,
        #                 "side": "buy",
        #                 "taker_or_maker": "taker",
        #                 "timestamp": 1675780847920,
        #                 "total_value": 49,
        #                 "type": "limit"
        #             },
        #             "user_id": "30B8CDBB-BDBD-4B60-A90F-860AB46B76F7"
        #         }
        #     }
        #
        return trades

    async def watch_orders(self, symbol: Optional[str] = None, since: Optional[int] = None, limit: Optional[int] = None, params={}):
        """
        watches information on multiple orders made by the user
        :param str|None symbol: not used by ripio watchOrders
        :param int|None since: not used by ripio watchOrders
        :param int|None limit: not used by ripio watchOrders
        :param dict params: not used by ripio watchOrders
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        name = 'order_status'
        messageHash = name
        url = self.urls['api']['ws']
        ticket = await self.fetchWebSocketTicket()
        subscription = {
            'topics': [name],
            'method': 'subscribe',
            'ticket': ticket,
            'messageHash': messageHash,
            'methodToCall': self.parse_order,
        }
        order = await self.watch(url, messageHash, subscription, messageHash, subscription)
        #
        #     {
        #         "topic": "order_status",
        #         "timestamp": 1672856713677,
        #         "body": {
        #             "amount": 4,
        #             "average_execution_price": 6,
        #             "id": "F55E4E01-C39B-4AA7-848B-1C6A362C386E",
        #             "created_at": "2023-01-24T17:28:32.247Z",
        #             "executed_amount": 4,
        #             "external_id": null,
        #             "pair": "ETH_BRL",
        #             "price": 6,
        #             "remaining_amount": 0,
        #             "side": "buy",
        #             "status": "executed_completely",
        #             "type": "limit",
        #             "updated_at": "2023-01-24T17:28:33.993Z",
        #             "user_id": "30B8CDBB-BDBD-4B60-A90F-860AB46B76F7"
        #         }
        #     }
        #
        return order

    def handle_trade(self, client: Client, message, subscription):
        #
        # watchTrades(public)
        #
        #      {
        #          "amount": 0.2404764,
        #          "date": "2019-01-03T02:27:33.947Z",
        #          "id": "2B222F22-5235-45FA-97FC-E9DBFA2575EE",
        #          "maker_order_id": "F49F5BD8-3F5B-4364-BCEE-F36F62DB966A",
        #          "maker_side": "buy",
        #          "maker_type": "limit",
        #          "pair": "ETH_BRL",
        #          "price": 15160,
        #          "taker_order_id": "FEAB5CEC-7F9E-4F95-B67D-9E8D5C739BE3",
        #          "taker_side": "sell",
        #          "taker_type": "market",
        #          "timestamp": 1675780847920,
        #          "total_value": 3638.4
        #      }
        #
        # watchMyTrades(private)
        #
        #      {
        #          "amount": 1,
        #          "date": "2023-01-09T13:39:24.057Z",
        #          "fee": 0,
        #          "fee_currency": "BCH",
        #          "id": "08799ECC-F6B1-498E-B89C-2A05E6A181B9",
        #          "pair_code": "BCH_BRL",
        #          "price": 49,
        #          "side": "buy",
        #          "taker_or_maker": "taker",
        #          "timestamp": 1675780847920,
        #          "total_value": 49,
        #          "type": "limit"
        #      }
        #
        payload = self.safe_value(message, 'body')
        if payload is None:
            return message
        symbol = self.safe_string(subscription, 'symbol')
        symbol = self.symbol(symbol)
        messageHash = self.safe_string(subscription, 'messageHash')
        market = self.market(symbol)
        trade = self.parse_trade(payload, market)
        tradesArray = self.safe_value(self.trades, symbol)
        if tradesArray is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            tradesArray = ArrayCache(limit)
            self.trades[symbol] = tradesArray
        tradesArray.append(trade)
        client.resolve(tradesArray, messageHash)

    def handle_ticker(self, client: Client, message, subscription):
        #
        # watchTicker(public)
        #
        #      {
        #          "ask": 4.01,
        #          "base_code": "ETH",
        #          "base_id": "13A4B83B-E74F-425C-BC0A-03A9C0F29FAD",
        #          "bid": 5,
        #          "date": "2022-09-28T19:13:40.887Z",
        #          "high": 20,
        #          "last": 20,
        #          "low": 20,
        #          "pair": "ETH_BRL",
        #          "price_change_percent_24h": "-16.66",
        #          "quote_id": "48898138-8623-4555-9468-B1A1505A9352",
        #          "quote_code": "BRL",
        #          "quote_volume": 600,
        #          "trades_quantity": 10,
        #          "volume": 124
        #      }
        #
        payload = self.safe_value(message, 'body')
        if payload is None:
            return message
        ticker = self.parse_ticker(payload)
        symbol = self.safe_string(subscription, 'symbol')
        symbol = self.symbol(symbol)
        self.tickers[symbol] = ticker
        messageHash = self.safe_string(subscription, 'messageHash')
        if messageHash is not None:
            client.resolve(ticker, messageHash)
        return message

    def handle_order_book(self, client: Client, message, subscription):
        #
        # watchOrderBook(public)
        #
        #      {
        #          "asks": [
        #              {
        #                  "amount": 10,
        #                  "price": 25
        #              }
        #          ],
        #          "bids": [
        #              {
        #                  "amount": 20,
        #                  "price": 4
        #              }
        #          ],
        #          "pair": "ETH_BRL"
        #      }
        #
        payload = self.safe_value(message, 'body')
        if payload is None:
            return message
        symbol = self.safe_string(subscription, 'symbol')
        symbol = self.symbol(symbol)
        timestamp = self.safe_integer(message, 'timestamp')
        orderbook = self.parse_order_book(payload, symbol, timestamp, 'bids', 'asks', 'price', 'amount')
        messageHash = self.safe_string(subscription, 'messageHash')
        client.resolve(orderbook, messageHash)
        return orderbook

    def handle_balance(self, client: Client, message, subscription):
        #
        # watchBalance(private)
        #
        #      {
        #          "user_id": "299E7131-CE8C-422F-A1CF-497BFA116F89",
        #          "balances": [
        #              {
        #                  "available_amount": 3,
        #                  "currency_code": "ETH",
        #                  "locked_amount": 1
        #              }
        #          ]
        #      }
        #
        payload = self.safe_value(message, 'body')
        if payload is None:
            return message
        messageHash = self.safe_string(subscription, 'messageHash')
        balances = self.safe_value(payload, 'balances')
        result = {}
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'currency_code')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_number(balance, 'available_amount')
            account['used'] = self.safe_number(balance, 'locked_amount')
            account['total'] = self.safe_number(balance, 'available_amount') + self.safe_number(balance, 'locked_amount')
            result[code] = account
        safeBalance = self.safe_balance(result)
        if messageHash is not None:
            client.resolve(safeBalance, messageHash)
        return safeBalance

    def handle_delta(self, bookside, delta):
        price = self.safe_float(delta, 'price')
        amount = self.safe_float(delta, 'amount')
        bookside.store(price, amount)

    def handle_deltas(self, bookside, deltas):
        for i in range(0, len(deltas)):
            self.handle_delta(bookside, deltas[i])

    def handle_message(self, client: Client, message):
        keys = list(client.subscriptions.keys())
        firstKey = self.safe_string(keys, 0)
        subscription = self.safe_value(client.subscriptions, firstKey, {})
        methodToCall = self.safe_value(subscription, 'methodToCall')
        if methodToCall is not None:
            return methodToCall(client, message, subscription)
        return message
